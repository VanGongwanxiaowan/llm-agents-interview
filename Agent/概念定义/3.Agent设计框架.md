### 3. 介绍一下，Agent设计框架
目前，关于 Agent的框架设计标准，呈现百花齐放的态势。文中展现设计框架分类，是一些大厂的分类。大家阅读后，选择性接收。
#### 3.1 Agent常见设计框架
##### 3.1.1 Anthropic
Anthropic 把涉及到智能体的内容统一叫为：**agentic systems**，在细节处对Workflow 和 Agent 做出了重要的**架构区分**，因此二者属于两类不同的系统：
- Workflow：**通过预定义的代码路径来编排大模型和和工具**；
  systems where LLMs and tools are orchestrated through predefined code paths.
- Agent：**大模型动态决定自己的流程及使用什么工具，自主控制如何完成任务**。
  systems where LLMs dynamically direct their own processes and tool usage, maintaining control over how they accomplish tasks
###### 3.1.1.1 Workflow
a) 提示链（Prompt chaining）

提示链将任务分解为一系列顺序的子任务，

- 每个 LLM call 处理前一个 LLM call 的输出；

- 可以在中间任何步骤添加检查点（图中的“Gate”），以确保处理过程仍在正轨上。

<img width="655" height="231" alt="image" src="https://github.com/user-attachments/assets/3ad3a870-b847-4e46-87bd-03d3f186037d" />



b) 路由（Routing）

通过路由对输入进行分类，并将其转发到专门的后续任务（specialized followup task）。

- 将任务的关注点进行拆解，从而针对每个具体任务设计和调整提示词。

- 否则，（all-in-one）提示词不仅很长，而且针对任何一种任务的提示词优化都可能会导致其他任务的性能下降。

<img width="432" height="182" alt="image" src="https://github.com/user-attachments/assets/8ad935af-9164-4e13-b25a-125a12dff8ff" />



c) 并行化（Parallelization）

多个任务同时进行，然后对输出进行聚合处理。考虑两个场景：

1. 分段（Sectioning）：类似 MapReduce，将任务分解为独立的子任务并行运行，最后对输出进行聚合。

2. 投票（Voting）：相同的任务并行执行多次，以获得多样化的输出。


<img width="383" height="143" alt="image" src="https://github.com/user-attachments/assets/0c671f95-7703-491d-a412-ecea4c311350" />


d) 编排者-工作者（Orchestrator-workers）

在这种 Workflow 中，一个中心式 LLM 动态地分解任务，将其委托给 worker LLM，并汇总它们的结果。

<img width="433" height="137" alt="image" src="https://github.com/user-attachments/assets/b9d47600-c660-40ea-ac7d-fd2c3d9349dc" />


e) 评估者-优化者（Evaluator-optimizer）

在这种 Workflow 中，一个 LLM call 生成响应，而另一个提供评估和反馈，形成一个闭环。

<img width="348" height="147" alt="image" src="https://github.com/user-attachments/assets/f1b3c471-28d7-4b6c-9c79-e992cdd3f666" />


##### 3.1.1.2 Agent

Agent 一般从下面场景收到任务并开始执行：

1. **收到明确的人类指令**；

2. **与人类交流到一定程度时，理解了自己接下来应该做什么**。


一旦任务明确，Agent 就会独立规划和执行，中间也可能会问人类一些问题，以获取更多信息或帮助它自己做出正确判断。

- 在 Agent 执行过程中，对它来说最重要的是每一步执行之后，都能**从环境中获得“真实信息”**（例如工具调用或执行代码），以帮助它评估任务的进展。

- Agent 可以在检查点或遇到障碍时暂停，然后**向人类获取帮助**。

- 任务通常在完成时终止，但也可以包括**停止条件**（例如最大迭代次数），以避免 Agent 行为不可控。



在实现 Agent 时，建议遵循三个核心原则：

1. Agent **设计的简洁性**。

2. Agent **工作过程的透明性**，例如能明确显示 Agent 的规划和步骤。

3. 通过完善的文档和测试，**精心设计 Agent 与计算机之间的接口** (agent-computer interfaces, ACI)。


小结：

不管是 Workflow 还是 Agent，都是一种**模式**，而不是**规范**，开发者可以组合和改造这些模式来实现自己的 AI 系统。成功的关键，是能**衡量系统的性能**，然后不断对实现进行改进和迭代。

大模型领域的成功并不是构建最复杂的系统，而是构建**符合你需求的系统**。从简单的提示词开始，不断评估和优化，只有在简单的解决方案真的解决不了问题时，才应该考虑引入 multi-step agentic systems。或者换句话说，**只有在性能有明显改善时**，才应该考虑增加复杂性。

##### 3.1.2 OpenAI
OpenAI 把框架设计成为编排（Orchestration），共分为两类：

1. **单智能体系统**：由一个配备了适当工具和指令的模型在循环中执行工作流。

2. **多智能体系统**：在多个互相协调的 Agent 之间执行工作流。

###### 3.1.2.1 单智能体系统

单个 Agent 可以通过逐步添加工具来处理许多任务，这样可以控制复杂性，简化评估和维护。

每个编排方法都需要“运行”的概念，通常实现为一个循环，让智能体一直运行，直到满足退出条件。常见的退出条件包括**工具调用**、**特定的结构化输出**、**错误或达到最大轮数**。

<img width="474" height="318" alt="image" src="https://github.com/user-attachments/assets/0e16214c-247e-4cb7-9b76-078e86dc7902" />



###### 3.1.2.2 何时考虑使用多智能体系统？

我们的一般建议是：**优先充分发挥单智能体系统的能力**。

以下是常见需要拆分 Agent 的两个参考标准：

1. **逻辑复杂**：当提示词中包含大量的条件判断（如多个 if-then-else 分支），或模板逻辑变得难以维护时，建议按逻辑片段将任务拆分给不同 Agents 分别处理。

2. **工具过载**：问题不在于工具数量本身，而在于它们之间的相似度和重叠度。有些系统能成功管理 15 个以上定义清晰的工具，而另一些则在不到 10 个模糊重叠的工具中就出现混乱。



###### 3.1.2.3 多智能体系统

多智能体系统可以根据不同的业务流程和场景需求，设计出各种结构。

但从实际客户经验来看，我们总结出两种通用、可落地的设计模式：

1. **管理者模式**（Agent 作为工具本身），由一个中心 Agent 担任“管理者”角色，通过工具调用的方式调度多个专职 Agent，每个 Agent 负责一个具体任务或领域。

<img width="929" height="199" alt="image" src="https://github.com/user-attachments/assets/e7936dc9-229a-4f73-ab46-6a8810c9a29c" />


2. **去中心化模式**（Agent 之间相互交接）多个 Agent 平行运行，彼此间根据各自专长进行任务接力和分工协作。

<img width="795" height="319" alt="image" src="https://github.com/user-attachments/assets/19390241-15da-4bbb-aafc-74f18eaa2ed6" />


多 Agent 系统可以被抽象为一张图谱，图中的节点代表 Agent：**在管理者模式中，连线表示工具调用；在去中心化模式中，连线表示任务的转交和流转**。


### 3.1.3 Google
Agent 架构中有三个核心组件，如图所示：

<img width="586" height="354" alt="image" src="https://github.com/user-attachments/assets/563444f6-0a89-42ba-9b2c-912e0552cccc" />


##### 3.1.3.1 模型（model）
这里指的是**用作 Agent 中做核心决策的语言模型（LM）**。
- 可以是一个或多个任何大小的模型，能够遵循基于指令的推理和逻辑框架，如 ReAct、Chain-of-Thought、Tree-of-Thoughts。
- 可以是通用的、多模态的，或根据特定 Agent 架构的需求微调得到的模型。
- 可以通过“能展示 Agent 能力的例子或数据集”来进一步微调模型，例如 Agent 在什么上下文中使用什么工具，或者执行什么推理步骤。

##### 3.1.3.2 工具（tool）


基础模型在文本和图像生成方面非常强大，但无法与外部世界联动极大限制了它们的能力。工具的出现解决了这一问题。**有了工具，Agent 便能够与外部数据和服务互动，大大扩展了它们的行动范围**。

工具可以有多种形式，常见是 Web API 方式，即 GET、POST、PATCH 和 DELETE 方法。例如，结合用户信息和获取天气数据的 tool，Agent 可以为用户提供旅行建议。

有了工具，Agent 可以访问和处理现实世界的信息，这使它们能够支撑更专业的系统，如检索增强生成（RAG），显著扩展了 Agent 的能力。


##### 3.1.3.3 编排层（orchestration）

**编排层描述了一个循环过程**：Agent 如何接收信息，如何进行内部推理，如何使用推理结果来指导其下一步行动或决策。

- 一般来说，这个循环会持续进行，直到 Agent 达到其目标或触发停止条件。

- 编排层的复杂性跟 Agent 及其执行的任务直接相关，可能差异很大。例如，一些编排就是简单的计算和决策规则，而其他的可能包含链式逻辑、额外的机器学习算法或其他概率推理技术。

### 3.2 建议框架一：Agent框架三种循环类型

https://mp.weixin.qq.com/s/0X58GzqPHbN9Sw5begW_w

目前，大厂对 Agent 框架的分类方法各有不同，有的强调技术栈（如基于 LLM 的、基于规则的），有的强调功能定位（如对话型、任务型、工具调用型），还有的从交互模式来区分（如单体 Agent 与多 Agent 协作）。

这些分类方法各有价值，但往往存在边界模糊、定义不一的问题。相比之下，通过**系统可控性与自动化程度**为标准来划分，更直观也更便于理解。

基于这一思路，可以将 Agent 框架分为三类：**手动 Agent 框架（白盒系统）**、**半自动 Agent 框架（灰盒系统）**、**全自动 Agent 框架（黑盒系统）**。这种分类方式不仅能体现系统的“黑箱程度”，也能帮助我们更清晰地理解不同 Agent 在实际应用中的定位与适用场景。

#### 3.2.1 手动 Agent 框架【白盒系统】

开发者预先设定好任务执行的每一步计划，明确规定哪个步骤使用哪个工具，LLM 主要负责在预设节点上填充内容或做简单决策。

可以称之为**工作流（Workflow）**，它是一个白盒系统。

Dify 和 Coze 就是典型的代表，能够提供可视化流程编排工具。此时 Tools 的执行步骤，在很多时候是被人强制执行的，以此换取更多的确定性。

<img width="805" height="310" alt="image" src="https://github.com/user-attachments/assets/d491ae89-af0c-4f14-91be-58b661716ecc" />


#### 3.2.2 半自动 Agent 框架【灰盒系统】

将 AI 预设为不同身份的垂直 Agent（系统提示词+特定工具），每个垂直 Agent 完成不同的子任务，最后通过框架将每个子任务的执行过程和结果组合起来，完成最终目标。

可以称之为**Multi-Agent System（多 Agent 系统）**，它是一个**灰盒系统**。

Manus 和扣子空间的规划模式就是典型的多 Agent 框架。规划和记忆管理都属于编排的一部分。

<img width="937" height="560" alt="image" src="https://github.com/user-attachments/assets/6e6ce8e4-2d0e-4f30-b13b-37a78cd3c1b5" />


#### 3.2.3 全自动 Agent 框架【黑盒系统】

只给模型设定一个最终目标，模型接收到目标就开始自我循环，直到完成目标或遇到无法解决的障碍。

全自动 Agent 框架是最简洁的，调用工具的那几行代码，就是**其全部的核心了，复杂过程全部交由模型去解决**。

可以称之为**Single-Agent System（单 Agent 系统）**，也就是所谓的通用 Agent，它是一个**黑盒系统**。

模型自主完成工具调用这个操作，就是全自动 Agent 框架了，如果模型没有 Tool Use 功能，也可以通过代码来实现。

<img width="936" height="353" alt="image" src="https://github.com/user-attachments/assets/03e0dbf4-8241-4856-a86a-d50c7c102972" />



| 框架名称                | 分类          | 系统类型 | 工具调用方式                                                                 | 编排逻辑                 | 示例平台           |
| ----------------------- | ------------- | -------- | ---------------------------------------------------------------------------- | ------------------------ | ------------------ |
| Workflow<br>LLM + Tools + Workflow | 手动 Agent    | 白盒     | 以工作流编排为核心，将 LLM 对话能力和工具调用作为节点加入到工作流中完成任务 | 静态流程图或节点规则     | Dify、Coze         |
| Multi Agent<br>LLM + Tools + Orchestration | 半自动 Agent  | 灰盒     | 将能力拆分为多个 Agent 角色，通过不同的编排方式进行组合完成任务             | 多 Agent 之间协作 + 记忆管理 | Manus、扣子空间    |
| Single Agent<br>LLM + Tools | 全自动 Agent  | 黑盒     | 单模型通过自我循环的方式自主规划并调用工具完成任务                           | 无显式编排，由模型自行推理 | Openai Deep Research |

### 3.3 建议框架二：Lilian Weng


https://lilianweng.github.io/posts/2023-06-23-agent/

<img width="1150" height="295" alt="image" src="https://github.com/user-attachments/assets/7c008f7a-1b3c-48d5-a7d0-8050fdba31f6" />


在一个由LLM驱动的自主系统中，LLM充当 Agent 的大脑，并辅以几个关键组成部分：
- **规划（Planning）**
  - 子目标与分解（Subgoal and decomposition）：Agent 将大型任务分解为更小、更易于处理的子目标，从而实现对复杂任务的高效处理。
  - 反思与完善（Reflection and refinement）：Agent 可以对过去的行动进行自我批评和自我反思，从错误中吸取教训，并为未来的步骤进行改进，从而提高最终结果的质量。
- **记忆（Memory）**
  - 短期记忆（Short-term memory）：所有上下文学习都是利用模型的短期记忆来学习。
  - 长期记忆（Long-term memory）：这为 Agent 提供了在长时间内保留和回忆（无限）信息的能力，通常通过利用外部向量存储和快速检索来实现。
- **工具的使用（Tool use）**
  - Agent 会调用外部API获取模型权重中缺失的额外信息（预训练后通常很难改变），包括当前信息、代码执行能力、访问专有信息源等。

### 3.4 总结
- **Anthropic**
  - 把涉及到智能体的内容统一叫为：**agentic systems**，在细节处对Workflow 和 Agent 做出了重要的架构区分。**Workflow**：通过预定义的代码路径来编排大模型和和工具；**Agent**：大模型动态决定自己的流程及使用什么工具，自主控制如何完成任务。
- **OpenAI**
  - 把框架设计成为编排（Orchestration），共分为两类：**单智能体系统**：由一个配备了适当工具和指令的模型在循环中执行工作流。**多智能体系统**：在多个互相协调的 Agent 之间执行工作流。
- **Google**：
  - Agent 架构中有三个核心组件：**模型（model）**、**工具（tool）**和**编排层（orchestration）**。
- **建议框架一**：
  - Agent 框架可以根据**系统可控性与自动化程度**分为三类：**手动 Agent 框架（白盒系统）**、**半自动 Agent 框架（灰盒系统）**、**全自动 Agent 框架（黑盒系统）**。需要强调的是，这 3 种框架并不是对立关系，而是常常组合使用。
- **建议框架二（Lilian Weng）**：
  - 在一个由LLM驱动的自主系统中，LLM充当 Agent 的大脑，并辅以几个关键组成部分：**规划（Planning）**、**记忆（Memory）**和**工具的使用（Tool use）**。
