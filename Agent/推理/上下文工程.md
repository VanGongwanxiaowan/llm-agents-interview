<img width="1300" height="790" alt="image" src="https://github.com/user-attachments/assets/b70d6492-8923-4b2a-8122-428aafc0e3e1" />

https://www.youtube.com/watch?v=0J20wMjfuEc
20250829

<img width="582" height="372" alt="image" src="https://github.com/user-attachments/assets/1aca2009-5c8b-47e7-9ce4-03216203766c" />


### **视频核心主题**
多数AI Agent的失败，并非由于大模型自身能力不足，而是由于**上下文工程** 的失败。视频旨在系统性地阐述“上下文工程”的概念、必要性、实践方法及其与相关技术（如提示词工程、RAG）的关系。

### **第一部分：什么是上下文？**

1.  **上下文的本质定义**：
    -   不仅仅是聊天记录，而是**提供给大模型、用于完成下一步推理或生成任务的“全部信息集合”**。

2.  **上下文的三大核心类别**：
    -   **指导性上下文**：指导模型“该做什么”以及“如何做”。
        -   **包含内容**：系统提示词、任务描述、少样本示例、输出格式定义。
        -   **关联技术**：提示词工程主要优化此类上下文。
    -   **信息性上下文**：告诉模型“需要知道什么”知识。
        -   **包含内容**：RAG检索的结果、记忆（短期/长期）、状态、思考草稿纸。
    -   **行动性上下文**：告诉模型“能做什么”以及“行动后的结果”。
        -   **包含内容**：工具定义、工具调用及结果、工具追踪。

3.  **核心结论**：上下文是一个**多维、动态、服务于特定任务的系统性概念**，远不止聊天记录那么简单。

### **第二部分：什么是上下文工程？**

1.  **权威定义**：
    -   **Tobi Lütke**：提供所有上下文，以便让LLM能合理解决任务的“艺术”。
    -   **Andrej Karpathy**：在工业级大模型应用中，是一门微妙的**艺术与科学**，目的是在上下文窗口中填入恰到好处的信息，为下一步推理做准备。

2.  **综合定义**：
    -   上下文工程是一门**系统性学科**，专注于**设计、构建并维护一个动态系统**，负责为Agent执行任务的每一步**智能地组装出最优的上下文组合**，以确保任务被可靠、高效地完成。

3.  **核心类比（来自Karpathy）**：
    -   **Agent** = 新型操作系统
    -   **模型** = CPU
    -   **上下文窗口** = 内存
    -   **上下文工程** = **内存管理器**
    -   **职责**：智能调度，决定在每个“时钟周期”哪些数据应被加载、换出或优先处理，以保证系统流畅运行和结果准确。

4.  **范式升级**：从优化单次交互的**提示词工程**，转向构建一个最高效的**信息供给系统**。

### **第三部分：上下文工程与提示词工程、RAG的关系**

-   **不是排斥，而是协作与包含**。
-   **提示词工程**：
    -   **层级**：更细粒度。
    -   **范畴**：主要优化**指导性上下文**（单次交互的指令部分）。
    -   **性质**：面向具体问题、单轮交互的工程实践。
-   **RAG**：
    -   **层级**：上下文工程的一个子集。
    -   **范畴**：主要负责**信息性上下文**的检索。
    -   **关系**：上下文工程不仅决定“检索什么”，还要考虑如何将检索到的信息与**指导性**和**行动性**上下文进行动态组合，并在RAG失败时启用备用方案（如其他工具）。
-   **核心结论**：**上下文工程的范畴远大于提示词工程和RAG**。

### **第四部分：为什么我们需要上下文工程？**

1.  **根本原因**：当Agent输出不及预期时，原因更多是**上下文信息的缺失**，而非模型能力不足。模型因缺乏关键信息而被迫进行不确定假设，甚至产生幻觉。

2.  **例证一：回复邮件（上下文贫乏 vs. 上下文充足）**
    -   **贫乏Agent**：仅看到邮件内容“明天有空聚一下吗？”。回应机械，无法推进任务。
    -   **充足Agent**：动态组装了多维上下文：
        -   *信息性*：检索日历（明天已满）、识别发件人（重要合作伙伴）、分析过往邮件（应采用非正式语气）。
        -   *行动性*：提供了“发送日历邀请”工具。
    -   **结果**：生成高效、可执行的回复（提议其他时间并发送邀请）。
    -   **结论**：性能鸿沟源于**是否能为特定任务动态组装合适的上下文**。

3.  **例证二：长期复杂任务（无差别累加上下文的弊端）**
    -   **场景**：在大型代码库中实现新功能，持续数天。
    -   **朴素策略**：将全部交互历史（指令、文件读取、错误、工具调用等）完整传递给模型。
    -   **三大后果**：
        -   **性能下降**：早期无关细节稀释核心信息，造成**上下文干扰**。
        -   **成本与延迟激增**：Token数量线性膨胀。
        -   **架构限制**：**上下文溢出**，导致任务中断或因信息截断而产生错误。
    -   **结论**：上下文工程旨在通过**智能管理与压缩**来解决这些问题。

### **第五部分：如何实施上下文工程？—— 四大最佳实践框架**

参考Lance的博客，框架分为四个部分：

1.  **写入**：将上下文持久化，超越窗口限制，供未来取用。
    -   **会话内写入**：写入会话内的“草稿纸”，管理当前任务复杂性（轻量、非持久）。
    -   **持久化写入**：写入外部记忆系统（如向量数据库），实现跨会话知识积累（如ChatGPT, Cursor）。

2.  **选取**：在每次模型调用前，动态拉取与当前子任务最相关的信息。
    -   **确定性选取**：根据预设规则加载（如Claude Code固定加载`CLAUDE.md`）。
    -   **模型驱动选取**：利用模型自身能力进行筛选。
    -   **检索式选取**：通过相似度检索从记忆或知识库中选取（最主流方式）。

3.  **压缩**：在信息进入上下文窗口前，进行有损或无损压缩，用更少Token承载核心信号。
    -   **自动压缩**：系统自动总结上下文，保留重点（如Claude Code的`auto-compact`，但目前不完善）。
    -   **修剪**：硬性截断超限历史（可能损失部分语境）。

4.  **隔离**：在系统架构层面，于多信息流间设置边界，由子流程先行消化，仅上交要点。
    -   **核心思想**：子Agent作为“智能过滤器”，在各自领域隔离并行工作，消化原始信息后，仅将**压缩后的关键洞见**提交给主Agent。
    -   **经典表现**：**多Agent架构**。
    -   **益处**：减轻主Agent认知负担，避免上下文干扰与冲突，提高信息密度。
    -   **与压缩的区别**：
        -   **压缩**：作用于**单一信息流内部**，提升其信息密度。
        -   **隔离**：作用于**多条信息流之间**，管理系统性复杂性，实现广义压缩。

### **第六部分：总结与展望**

1.  **核心结论重申**：AI Agent的失败，**是上下文工程的失败，而非模型能力的失败**。

2.  **开发哲学的转变**：工作重心从寻找“完美提示词”，转向设计能**动态组装完美上下文**的健壮系统。

3.  **四大实践的关键性**：理解和运用**写入、选取、压缩、隔离**，是区分“有趣演示”和“可靠、可规模化应用”的关键。

4.  **与MCP的关系**：
    -   MCP是面向工具与数据的标准化接口（上下文交换协议）。
    -   它本质上是为**行动性上下文**和部分**信息性上下文**的标准化交互所做的努力。
    -   因此，MCP是实现稳健上下文工程的**重要基础设施之一**，为其提供了标准化的接口。

5.  **最终目标**：无论提示词、RAG还是MCP，其共同目标都是在模型决策前，为它准备好**一份恰到好处的上下文**。

---
