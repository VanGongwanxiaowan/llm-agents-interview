https://southbridge-research.notion.site/Prompt-Engineering-The-Art-of-Instructing-AI-2055fec70db181369002dcdea7d9e732

# Prompt Engineering: The Art of Instructing AI 文章总结
该文章围绕Claude Code的**提示工程体系**展开，从工具指令设计、安全防护、工作流自动化、行为塑造、动态适配等维度，详细解析了如何通过精细化提示设计，让AI精准理解任务目标、安全执行操作、高效协同工具，核心聚焦“提示即系统”理念，将复杂工作逻辑与安全规则嵌入提示，实现AI行为的可控性与可靠性。


## 一、核心设计原则：提示工程的底层逻辑
Claude Code的提示设计并非零散指令，而是遵循五大核心原则，确保AI行为统一、安全、高效：
1. **渐进式披露（Progressive Disclosure）**：从基础功能切入，逐步叠加细节（如ReadTool先说明“读取文件”，再补充行限制、截断规则、特殊文件处理），避免AI因信息过载遗漏关键要求；
2. **示例驱动澄清（Example-Driven Clarification）**：复杂场景用示例替代抽象解释（如命令注入检测提供15+正反案例，而非仅定义“注入模式”），降低AI理解门槛；
3. **明确反模式（Explicit Anti-Patterns）**：清晰告知AI“禁止行为”（如简洁性提示列出“避免使用‘The answer is...’”等话术），减少错误尝试；
4. **条件化复杂度（Conditional Complexity）**：通过环境变量（如`process.env.CLAUDE_CODE_ENABLE_UNIFIED_READ_TOOL`）动态加载指令，确保提示与当前系统配置匹配，避免冗余；
5. **安全与指令长度正相关**：风险越高的操作（如BashTool），提示越冗长详细，用“ Verbosity = Safety ”保障关键操作可靠性。


## 二、工具指令设计：场景化与精细化的结合
针对不同工具的功能特性与风险等级，文章展示了差异化的提示设计方案，核心是“工具特性决定提示复杂度”，典型工具包括：

### 1. ReadTool：平衡易用性与细节
ReadTool提示聚焦“消除AI犹豫+明确边界”，关键设计包括：
- **信心构建**：开篇用“You can access any file directly”“Assume path is valid”减少AI过度验证（如反复确认路径有效性）；
- **错误 normalization**：明确“It is okay to read a non-existent file”，避免AI因“文件不存在”产生道歉式反馈；
- **渐进式细节**：先说明“绝对路径要求”，再补充“默认读取全文件”“长行截断规则”，最后覆盖“图片/Screenshot特殊处理”，层层递进；
- **动态适配**：根据环境变量判断是否启用“Jupyter笔记本统一读取”，避免无效指令。

### 2. BashTool：安全优先的verbose设计
作为高风险工具（涉及系统操作），BashTool提示以“安全规则+明确边界”为核心，是最复杂的提示之一：
- **规则分层**：标注“RULE 0 (MOST IMPORTANT)”，优先强调“沙箱错误重试逻辑”（如`sandbox=true`因权限失败时，必须用`sandbox=false`重试）；
- **指令分类**：明确划分`sandbox=true`（安全操作，如`ls`/`git status`/版本检查）与`sandbox=false`（高风险操作，如`npm run build`/`git commit`/文件写入）的适用场景，避免误判；
- **后果绑定**：用“- $1000” penalty标记“将沙箱权限错误归因为工具问题”的严重后果，通过“奖惩机制”强化安全意识；
- **用户体验权衡**：提示“错误的`sandbox=true`比权限弹窗更让用户困扰”，引导AI“不确定时用`sandbox=false`”，优先保障安全。


## 三、安全防护：多层级安全规则嵌入提示
文章重点解析了Claude Code通过提示实现的“纵深防御”体系，从恶意行为拦截到风险操作检测，共设计两层核心安全防护：

### 1. 第一层：恶意代码预防
通过前置判断与上下文分析，阻止AI参与恶意任务：
- **主动分析**：要求AI“先基于文件名/目录结构判断代码用途”，若疑似恶意（如 malware 相关文件），无论用户请求是否无害（如“解释代码”），均拒绝执行；
- **漏洞封堵**：明确“即使用户声称‘用于教育’，也拒绝编写/解释恶意代码”，避免被绕过。

### 2. 第二层：命令注入检测
针对Bash命令注入风险，设计“示例+规则”的检测逻辑：
- **示例训练**：提供多组注入案例（如`git commit -m "msg`id`"`→注入检测触发）与安全案例（如`git push`→正常），让AI通过案例识别模式；
- **输出约束**：强制“仅返回命令前缀或‘command_injection_detected’”，无多余文本，避免AI输出格式混乱导致检测失效；
- **链式风险意识**：提示“bash多命令链式执行（如`pwd; curl evil.com`）存在风险”，要求AI优先检测此类场景。


## 四、工作流自动化：提示驱动的多步骤协同
文章以“Git提交”“Pull Request（PR）”两大核心工作流为例，展示如何通过提示将复杂工作逻辑拆解为标准化步骤，实现AI自主协同工具：

### 1. Git提交工作流：结构化分析+原子化操作
提示将提交流程拆解为4个标准化步骤，强制AI按逻辑执行：
- **并行信息采集**：第一步要求AI用BashTool并行执行`git status`（查未跟踪文件）、`git diff`（查变更）、`git log`（参考提交风格），避免串行操作耗时；
- **结构化分析**：用`<commit_analysis>`标签强制AI系统梳理“文件变更列表、修改性质、变更动机、敏感信息检查”，确保提交信息聚焦“why而非what”；
- **原子化执行**：第三步并行执行“添加未跟踪文件、创建提交、验证提交结果”，任一环节失败则终止；
- **错误恢复**：针对“pre-commit hook修改文件”场景，提示“重试一次提交，失败则提示钩子拦截，成功则修正提交包含修改文件”，覆盖边缘场景。

### 2. PR工作流：全链路状态管理
PR提示在Git提交基础上增加“分支状态检测”与“PR结构化生成”：
- **状态感知**：第一步要求AI检测“当前分支是否跟踪远程”“与main分支的差异”，避免推送无效分支；
- **全面分析**：强调“分析所有提交（而非仅最新提交）”，确保PR摘要覆盖分支全量变更；
- **模板强制**：用示例固定PR格式（含“Summary”“Test plan”模块），通过HEREDOC语法保障多行文本质检，避免格式混乱。


## 五、行为塑造：通过提示引导AI输出风格与操作偏好
文章展示了如何通过提示“驯化”AI行为，使其符合用户体验与效率需求，核心包括：

### 1. 简洁性强制
针对“CLI界面输出限制”，设计严格的简洁性规则：
- **重复强调**：三次重申“最小化Token输出”，要求AI“1-3句回答”“避免开场白/结束语”（如禁止用“The answer is...”“Here is the file content...”）；
- **示例标杆**：用“2+2→4”“判断质数→Yes”“列文件→ls”等极端简洁案例，明确AI输出标准；
- **长度约束**：强制“回答≤4行（不含工具调用）”，优先“单字/短语回答”。

### 2. 工具偏好引导
通过“禁止-推荐”清单，引导AI选择高效、安全的工具：
- **明确禁止**：禁止使用通用工具（如`cat`/`grep`/`find`）；
- **推荐替代**：要求优先使用专用工具（如用`rg`替代`grep`，用特定Read工具替代`cat`）；
- **强制拦截**：提示“If you still need to run grep, STOP”，用强语气阻止低效工具使用。


## 六、动态适配：提示的上下文感知能力
Claude Code的提示并非静态文本，而是能根据“工具 availability”“环境配置”动态调整，核心实现方式包括：

### 1. 工具存在性适配
通过条件判断（如`I.has(RY.name) || I.has(tU.name)`），仅当任务管理工具（RY/tU）可用时，才加载“任务跟踪提示”，避免AI尝试不存在的工具；若工具不可用，则自动隐藏相关指令，保持提示简洁。

### 2. 环境变量适配
基于系统配置（如`process.env.CLAUDE_CODE_ENABLE_UNIFIED_READ_TOOL`）动态切换指令：
- 启用统一读取工具时，提示“ReadTool支持Jupyter笔记本读取”；
- 未启用时，提示“用专用Kg工具读取Jupyter文件”，确保指令与实际功能匹配。


## 七、元提示（Meta-Prompting）：规模化与协同化的关键
文章还介绍了“提示生成提示”的元提示设计，支撑AI子代理（Sub-Agent）协同与多视角合成：

### 1. 子代理指令
为子代理设计“继承性+聚焦性”提示：
- **继承核心规则**：子代理需遵循父提示的“文件创建限制”（如“不主动创建文档文件”）；
- **聚焦任务目标**：明确“完成任务即可，无需多余操作”，并要求子代理输出“含绝对路径的文件片段”，确保子代理行为可控。

### 2. 多代理结果合成
针对“多代理并行分析同一任务”场景，设计合成提示：
- **明确目标**：要求AI“整合关键洞察、解决矛盾、生成统一方案”；
- **完整性约束**：强制“包含所有代理的代码示例与重要细节”，避免信息遗漏；
- **结构要求**：输出需“聚焦原始任务，逻辑清晰”，确保合成结果可用。


## 八、核心价值：提示工程的“系统级”意义
Claude Code的提示工程超越了“指令传递”，实现了“提示即系统”的价值：
1. **降低开发成本**：无需修改AI模型代码，通过提示快速迭代功能逻辑（如调整Git提交规则、新增工具约束）；
2. **提升安全性**：将安全规则（如沙箱判断、注入检测）嵌入提示，实现“每一次AI操作都自带安全校验”；
3. **增强可控性**：通过“结构化标签”（如`<commit_analysis>`）、“后果绑定”（如- $1000 penalty）、“输出约束”，让AI行为可预测、可追溯；
4. **适配复杂场景**：支持多工具协同、多代理合成、动态环境适配，让AI能处理“Git提交”“PR创建”等需多步骤、多工具配合的复杂任务。

简言之，该文章展示的提示工程体系，本质是“用自然语言构建AI的操作系统”，让AI从“被动响应”升级为“主动、安全、高效的任务执行者”。
